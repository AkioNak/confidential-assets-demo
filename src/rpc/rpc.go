// Copyright (c) 2017 DG Lab
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

// Package rpc is a simple client
package rpc

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"lib"
	"net/http"
	"time"
)

// ValidatedAddress contains address details.
type ValidatedAddress struct {
	IsValid         bool   `json:"isvalid"`          // : true|false,        (boolean) If the address is valid or not. If not, this is the only property returned.
	Address         string `json:"address"`          // : "bitcoinaddress", (string) The bitcoin address validated
	ScriptPubKey    string `json:"scriptPubKey"`     // : "hex",       (string) The hex encoded scriptPubKey generated by the address
	IsMine          bool   `json:"ismine"`           // : true|false,        (boolean) If the address is yours or not
	IsWatchonly     bool   `json:"iswatchonly"`      // : true|false,   (boolean) If the address is watchonly
	IsScript        bool   `json:"isscript"`         // : true|false,      (boolean) If the key is a script
	PubKey          string `json:"pubkey"`           // : "publickeyhex",    (string) The hex value of the raw public key
	IsCompressed    bool   `json:"iscompressed"`     // : true|false,  (boolean) If the address is compressed
	Account         string `json:"account"`          // : "account"         (string) DEPRECATED. The account associated with the address, "" is the default account
	ConfidentialKey string `json:"confidential_key"` // : "pubkey" (string) The confidentiality key associated with the address, or "" if none
	Unconfidential  string `json:"unconfidential"`   // : "address"  (string) The address without confidentiality key
	Confidential    string `json:"confidential"`     // : "address"    (string) Confidential version of the address, only if it is yours and unconfidential
	Hdkeypath       string `json:"hdkeypath"`        // : "keypath"       (string, optional) The HD keypath if the key is HD and available
	Hdmasterkeyid   string `json:"hdmasterkeyid"`    // : "<hash160>" (string, optional) The Hash160 of the HD master pubkey
}

// Unspent contains unspent details.
type Unspent struct {
	Txid            string `json:"txid"`            // "txid"            : "txid",    (string)  the transaction id
	Vout            int64  `json:"vout"`            // "vout"            : n,         (numeric) the vout value
	Address         string `json:"address"`         // "address"         : "address", (string)  the bitcoin address
	Account         string `json:"account"`         // "account"         : "account", (string)  DEPRECATED. The associated account, or "" for the default account
	ScriptPubKey    string `json:"scriptPubKey"`    // "scriptPubKey"    : "key",     (string)  the script key
	Amount          int64  `json:"amount"`          // "amount"          : x.xxx,     (numeric) the transaction amount in BTC
	Asset           string `json:"asset"`           // "asset"           : "hex"      (string)  the asset id for this output
	AssetCommitment string `json:"assetcommitment"` // "assetcommitment" : "hex"      (string)  the asset commitment for this output
	Confirmations   int64  `json:"confirmations"`   // "confirmations"   : n,         (numeric) The number of confirmations
	SerValue        string `json:"serValue"`        // "serValue"        : "hex",     (string)  the output's value commitment
	Blinder         string `json:"blinder"`         // "blinder"         : "blind"    (string)  The blinding factor used for a confidential output (or "")
	RedeemScript    string `json:"redeemScript"`    // "redeemScript"    : n          (string)  The redeemScript if scriptPubKey is P2SH
	Spendable       bool   `json:"spendable"`       // "spendable"       : xxx,       (bool)    Whether we have the private keys to spend this output
	Solvable        bool   `json:"solvable"`        // "solvable"        : xxx        (bool)    Whether we know how to spend this output, ignoring the lack of keys
}

// UnspentList is an array of unspent outputs.
type UnspentList []*Unspent

// BalanceMap is a map where the key is an assetid and the value is a balance.
type BalanceMap map[string]float64

// Wallet is wallet details.
type Wallet struct {
	WalletVersion      int64      `json:"walletversion"`       // : xxxxx,       (numeric) the wallet version
	Balance            BalanceMap `json:"balance"`             // : xxxxxxx,     (numeric) the total confirmed balance of the wallet in BTC
	UnconfirmedBalance BalanceMap `json:"unconfirmed_balance"` // : xxx,         (numeric) the total unconfirmed balance of the wallet in BTC
	ImmatureBalance    BalanceMap `json:"immature_balance"`    // : xxxxxx,      (numeric) the total immature balance of the wallet in BTC
	TxCount            int64      `json:"txcount"`             // : xxxxxxx,     (numeric) the total number of transactions in the wallet
	KeypoolOldest      float64    `json:"keypoololdest"`       // : xxxxxx,      (numeric) the timestamp (seconds since GMT epoch) of the oldest pre-generated key in the key pool
	KeypoolSize        int64      `json:"keypoolsize"`         // : xxxx,        (numeric) how many new keys are pre-generated
	UnlockedUntil      int64      `json:"unlocked_until"`      // : ttt,         (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked
	PayTxFee           int64      `json:"paytxfee"`            // : x.xxxx,      (numeric) the transaction fee configuration, set in BTC/kB
	HDMasterKeyId      string     `json:"hdmasterkeyid"`       // : "<hash160>", (string) the Hash160 of the HD master pubkey
}

// ScriptSig is script details.
type ScriptSig struct {
	Asm string `json:"asm"`
	Hex string `json:"hex"`
}

// ScriptPubKey is pubkey details.
type ScriptPubKey struct {
	Asm       string   `json:"asm"`
	Hex       string   `json:"hex"`
	ReqSigs   int64    `json:"reqSigs"`
	Type      string   `json:"type"`
	Addresses []string `json:"addresses"`
}

// Vin is input details.
type Vin struct {
	Txid        string    `json:"txid"`
	Vout        int64     `json:"vout"`
	ScriptSig   ScriptSig `json:"scriptSig"`
	txinwitness string    `json:"txinwitness"`
	sequence    int64     `json:"sequence"`
}

// Vout is output details.
type Vout struct {
	Value        float64      `json:"value"`
	N            int64        `json:"n"`
	Asset        string       `json:"asset"`
	Assettag     string       `json:"assettag"`
	ScriptPubKey ScriptPubKey `json:"scriptPubKey"`
}

// RawTransaction is transaction details.
type RawTransaction struct {
	Txid     string  `json:"txid"`
	Hash     string  `json:"hash"`
	Size     int64   `json:"size"`
	Vsize    int64   `json:"vsize"`
	Version  int64   `json:"version"`
	LockTime int64   `json:"locktime"`
	Fee      float64 `json:"fee"`
	Vin      []Vin   `json:"vin"`
	Vout     []Vout  `json:"vout"`
}

// SignedTransaction is transaction details.
type SignedTransaction struct {
	Hex      string `json:"hex"`
	Complete bool   `json:"complete"`
}

// Rpc is request info.
type Rpc struct {
	Url  string
	User string
	Pass string
	View bool
}

// RpcRequest is request parameters.
type RpcRequest struct {
	Jsonrpc string        `json:"jsonrpc,"`
	Id      string        `json:"id,"`
	Method  string        `json:"method,"`
	Params  []interface{} `json:"params,"`
}

// RpcResponse is response details.
type RpcResponse struct {
	Result interface{} `json:"result,"`
	Error  interface{} `json:"error,"`
	Id     string      `json:"id,"`
}

// RpcError is error details.
type RpcError struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

// UnmarshalError converts the error response into an RpcError type
func (res *RpcResponse) UnmarshalError() (RpcError, error) {
	var rerr RpcError
	if res.Error == nil {
		return rerr, fmt.Errorf("RpcResponse Error is nil.")
	}
	data, ok := res.Error.(map[string]interface{})
	if !ok {
		return rerr, fmt.Errorf("RpcResponse Error is not map[string]interface{}")
	}
	bs, _ := json.Marshal(data)
	json.Unmarshal(bs, &rerr)
	return rerr, nil
}

// UnmarshalResult converts the response into an result type
func (res *RpcResponse) UnmarshalResult(result interface{}) error {
	if res.Result == nil {
		return fmt.Errorf("RpcResponse Result is nil.")
	}
	var bs []byte
	m, ok := res.Result.(map[string]interface{})
	if !ok {
		arr, ok := res.Result.([]interface{})
		if !ok {
			return fmt.Errorf("RpcResponse Result is neither map[string]interface{} nor []interface{}")
		}
		bs, _ = json.Marshal(arr)
	} else {
		bs, _ = json.Marshal(m)
	}
	err := json.Unmarshal(bs, result)
	if err != nil {
		return err
	}
	return nil
}

// NewRpc return new Rpc
func NewRpc(url, user, pass string) *Rpc {
	rpc := new(Rpc)
	rpc.Url = url
	rpc.User = user
	rpc.Pass = pass
	return rpc
}

// Request request server
func (rpc *Rpc) Request(method string, params ...interface{}) (RpcResponse, error) {
	var res RpcResponse
	var err error
	var ok bool

	if len(params) == 0 {
		params = []interface{}{}
	}

	in := make([]interface{}, 3)
	in[0] = rpc
	in[1] = method
	in[2] = params
	out := <-lib.GetDispatcherInstance().Enqueue(ProccesRequest, in)

	if len(out) != 2 {
		return res, fmt.Errorf("Illegal numbers of output:%v", out)
	}

	if out[0] == nil {
		if out[1] == nil {
			return res, fmt.Errorf("both res and err are nil")
		}
	} else {
		res, ok = out[0].(RpcResponse)
		if !ok {
			return res, fmt.Errorf("Type mismatch - not RpcResponse:%v", out[0])
		}
	}

	if out[1] == nil {
		return res, nil
	}

	err, ok = out[1].(error)
	if !ok {
		return res, fmt.Errorf("Type mismatch - not error:%v", out[1])
	}

	return res, err
}

func ProccesRequest(in []interface{}) []interface{} {
	out := make([]interface{}, 2)
	out[0] = nil
	out[1] = nil

	if len(in) != 3 {
		out[1] = fmt.Errorf("Illegal numbers of input:%d:%v", len(in), in)
		return out
	}

	rpc, ok := in[0].(*Rpc)
	if !ok {
		out[1] = fmt.Errorf("Type mismatch - not *Rpc: input[0]:%v", in[0])
		return out
	}
	method, ok := in[1].(string)
	if !ok {
		out[1] = fmt.Errorf("Type mismatch - not string: input[1]:%v", in[1])
		return out
	}

	if in[2] == nil {
		in[2] = []interface{}{}
	}
	params, ok := in[2].([]interface{})
	if !ok {
		out[1] = fmt.Errorf("Type mismatch - not []interface{}: input[2]:%v", in[2])
		return out
	}

	out[0], out[1] = rpc.RequestDirect(method, params...)

	return out
}

func (rpc *Rpc) RequestDirect(method string, params ...interface{}) (RpcResponse, error) {
	var res RpcResponse
	if len(params) == 0 {
		params = []interface{}{}
	}
	id := fmt.Sprintf("%d", time.Now().Unix())
	req := &RpcRequest{"1.0", id, method, params}
	bs, _ := json.Marshal(req)
	if rpc.View {
		fmt.Printf("%s\n", bs)
	}
	client := &http.Client{}
	hreq, _ := http.NewRequest("POST", rpc.Url, bytes.NewBuffer(bs))
	hreq.SetBasicAuth(rpc.User, rpc.Pass)
	hres, err := client.Do(hreq)
	if err != nil {
		return res, err
	}
	defer hres.Body.Close()
	body, _ := ioutil.ReadAll(hres.Body)
	if rpc.View {
		fmt.Printf("%d, %s\n", hres.StatusCode, body)
	}
	err = json.Unmarshal(body, &res)
	if err != nil || hres.StatusCode != http.StatusOK || res.Id != id {
		return res, fmt.Errorf("status:%v, error:%v, body:%s reqid:%v, resid:%v", hres.Status, err, body, id, res.Id)
	}
	return res, nil
}

// RequestAndUnmarshalResult do Request and UnmarshalResult
func (rpc *Rpc) RequestAndUnmarshalResult(result interface{}, method string, params ...interface{}) (RpcResponse, error) {
	res, err := rpc.Request(method, params...)
	if err != nil {
		return res, err
	}
	err = res.UnmarshalResult(result)
	if err != nil {
		return res, err
	}
	return res, nil
}

// RequestAndCastNumber do Request and cast float64
func (rpc *Rpc) RequestAndCastNumber(method string, params ...interface{}) (float64, RpcResponse, error) {
	var num float64
	res, err := rpc.Request(method, params...)
	if err != nil {
		return num, res, err
	}
	num, ok := res.Result.(float64)
	if !ok {
		return num, res, fmt.Errorf("RpcResponse Result cast error:%+v", res.Result)
	}
	return num, res, nil
}

// RequestAndCastString do Request and cast string
func (rpc *Rpc) RequestAndCastString(method string, params ...interface{}) (string, RpcResponse, error) {
	var str string
	res, err := rpc.Request(method, params...)
	if err != nil {
		return str, res, err
	}
	str, ok := res.Result.(string)
	if !ok {
		return str, res, fmt.Errorf("RpcResponse Result cast error:%+v", res.Result)
	}
	return str, res, nil
}

// RequestAndCastBool do Request and cast bool
func (rpc *Rpc) RequestAndCastBool(method string, params ...interface{}) (bool, RpcResponse, error) {
	var b bool
	res, err := rpc.Request(method, params...)
	if err != nil {
		return b, res, err
	}
	b, ok := res.Result.(bool)
	if !ok {
		return b, res, fmt.Errorf("RpcResponse Result cast error:%+v", res.Result)
	}
	return b, res, nil
}
